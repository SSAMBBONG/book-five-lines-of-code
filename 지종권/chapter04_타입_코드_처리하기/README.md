# 타입 코드 처리하기

## 간단한 if문 리팩터링

### if문에서 else를 사용하지 말 것

왜냐 ? -> else로 끝나는 부분에 다른 변형을 도입할 수 없기에 코드의 유연성이 떨어짐

if - else를 제거하는 첫 번째 단계는 **열거형에서 인터페이스**로 바꾸는 것

절차

1. 임시 이름을 가진 새로운 인터페이스를 도입합니다. 인터페이스에는 열거형(enum)의 각 값에 대한 메서드가 있어야 합니다.

2. 열거형의 각 값에 해당하는 클래스를 만듭니다. 클래스에 해당하는 메서드를 제외한 인터페이스의 모든 메서드는 false를 반환해야 합니다.

3. 열거형의 이름을 다른 이름으로 바꿉니다. 그렇게하면 컴파일러가 열거형을 사용하는 모든 위치에서 오류를 발생시킵니다.

4. 타입을 이전 이름에서 임시이름으로 변경하고 일치성 검사를 새로운 메서드로 대체합니다.

5. 남아있는 열거형값에 대한 참조 대신 새로운 클래스를 인스턴스화하여 교체합니다.

6. 오류가 더 이상 없으면 인터페이스의 이름을 모든 위치에서 영구적인 것으로 바꿉니다.

이렇게 함으로 얻는 이점은

메서드를 하니씩 처리할 수 있기 때문에 개선이 쉽다.

### 클래스로의 코드 이관

기능을 클래스로 옮기기 때문에, if 구문이 제거되고 기능이 데이터에 더욱 가까워진다.

절차

1. 원래 함수를 복사하여 모든 클래스로 붙여 넣습니다. 이제 메서드이므로 function 키워드를 제거합니다. 컨텍스트를 this로 바꾼 후 사용하지 않는 매개변수를 제거합니다. 메서드에 여전히 잘못된 이름이 존재하기 때문에 오류가 계속 발생합니다.

2. 메서드 선언 부분의 메서드 이름과 매개변수 리스트(메서드 시그니처)를 인터페이스에 복사하고 원래 메서드와 약간 다른 이름을 지정합니다.

3. 모든 클래스에서 새로운 메서드를 점검합니다.

   a 클래스에 맞게 조건식들의 true, false를 결정합니다.

   b 미리 계산할 수 있는 모든 계산을 수행합니다. 일반적으로 if (true)와 if (false) {...}를 제거하는 것과 같지만 먼저 조건을 단순화해야 할 수도 있습니다(예: false || true는 true).

   c 메서드 처리가 완료되었음을 알릴 수 있는 적절한 이름으로 변경합니다. 이때 컴파일러에서 에러가 발생하면 안 됩니다.

4. 원래 함수의 본문을 새로운 메서드에 대한 호출로 바꿉니다.

### 메서드 인라인화

1. 메서드 이름을 임시로 변경합니다 그러면 함수를 사용하는 모든 곳에서 컴파일러 오류가 발생합니다.

2. 메서드의 본문을 복사하고 매개변수를 기억해둡니다.

3. 컴파일러가 오류를 발생시킨 모든곳의 호출을 복사된 코드로 교체하고 인자를 매개변수에 매핑합니다.

4. 오류없이 컴파일되면 원래의 메서드가 더 이상 사용되지 않는것이므로 원래 메서드를 삭제합니다.

<br> <br> <br> <br>

그 뒤에 내용은 똑같은 내용 반복 ..

음..

요약

1. if - else 사용 x
2. switch 사용 x
3. 클래스로 타입 코드 대체 및 클래스로의 코드 이관 패턴 사용
